'use strict';
const { faker } = require('@faker-js/faker');

const vulnerabilityCategories = [
  'sql-injection',
  'cross-site-scripting',
  'broken-authentication',
  'sensitive-data-exposure',
  'security-misconfiguration',
  'unknown',
  // 'insecure-deserialization',
  // 'known-vulnerable-components',
  // 'csrf',
  // 'insufficient-logging-monitoring',
  // 'ssrf',
  // 'directory-traversal',
  // 'remote-code-execution',
  // 'path-injection',
  // 'buffer-overflow',
  // 'command-injection',
];

module.exports = {
  async up(queryInterface, Sequelize) {
    const length = await queryInterface.sequelize.query(
      `SELECT count(*) FROM Vulnerabilities;`
    )

    if (length) return;

    const [clients] = await queryInterface.sequelize.query(
      `SELECT clientId FROM Clients LIMIT 1;`
    );

    if (clients.length === 0) {
      throw new Error('No clients found. Seed Clients table first.');
    }

    const clientId = clients[0].clientId;

    const vulnerabilities = Array.from({ length: 100 }, () => ({
      clientId: clientId,
      title: faker.lorem.words(5),
      severity: faker.helpers.arrayElement(['low', 'medium', 'high', 'critical']),
      category: faker.helpers.arrayElement(vulnerabilityCategories),
      status: faker.helpers.arrayElement(['open', 'closed']),
      cvssScore: faker.number.float({ min: 0, max: 10, precision: 0.1 }),
      foundAt: faker.date.past(),
      createdAt: new Date(),
      updatedAt: new Date(),
    }));

    await queryInterface.bulkInsert('Vulnerabilities', vulnerabilities, {});
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.bulkDelete('Vulnerabilities', null, {});
  }
};
